let guess: u32 = "42".parse().expect("Not a number");
//we have to add type of the variable while parsing a string so the string knows in which data type we want to parse the variable

#Scalar Types
 >> represent a single value

$Integer Type
>> Eg :-
	length	Signed Unsigned
	8-bit	i8 	u8
	16-bit	i16 	u16
	32bit	i32	u32
	64-bit 	i64	u64
	128-bit	i128	u128
	arch	isize	usize

>> Integer literals in rust
	Number literals		Example
	Decimal			24_555
	Hex			0xef
	Octal			0o43
	Binary			0b111_000
	Byte(u8 only)		b'A'

$Floating point type
>>> f32 and f64 // floating datatypes 
>> let x = 2.0 //By default f64 data type is assigned to it as on modern CPU it takes the same time to process f64 and f32

$ Numeric Operators
> fn main(){
	//addition
	let sum = 5 + 10;
	
	//subtraction
	let difference = 89.2 - 54.4;

	//multiplication
	let product = 38*2;

	//division
	let quotient = 43.2/12.32;
	let truncated = -5 /3; //results in -1

	//remainder
	let remainder = 89%34;

$ Boolean operator
>> let f:bool = false;

$ Character type
//character literals are specified by single quotes
size = 4 bytes 
//represent a unicode scalar value which means it can represent a lot more than just ASCII
//Unicode scalar values range from U+0000 to U+D7FF and U+E00 to U+10FFFF incluse
> fn main(){
	let c = 'a';
	let b : char ='Z'; //with explicit type annotation
	let heart_eyed_cat = ' ' ;//here we can specify any emoji
}

# Compound Types

$ The Tuple Type
//tuples have a fixed length that cannot be changed
//element with different data type can be stored in tuple
> fn main(){
	let tup: (i32 , f64 , u8) = (500 , 6.4,1);
	let (x , y , z) = tup; //destructuring tuple
	let a = x.0;
	let b = x.1 ;
	let c = x.2;
}

$ The Array Type
//arrays in rust have a fixed length
//every element of the array must have the same data type
fn main(){
let a = [1,2,3,4,5,6];
let a:[i32;5]=[1,2,3,4,5];
// generates the array a containing a = 1 2 3 4 5
let a : [3;5] ;
//generates an array a containing a = 3 3 3 3 3
 
}

/*  *Accessing array elements
let a = [1,2,3,4,5,6];
let first = a[0];
let second = a[1];
	.
	.
	.
and so on


